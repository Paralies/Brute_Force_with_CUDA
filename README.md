## Brute_Force_with_CUDA

### 문제 설명
10가지 숫자, 52가지의 영문 대소문자, 그리고 아스키코드에 존재하는 32가지의 특수 문자를 조합하여 7가지 유형의 5에서 8 사이 길이의 암호를 각각 10개씩 생성한다. 이후, 생성된 암호를 brute force algorithm을 이용하여 대입해봄으로써 암호를 순차적으로 확인하여 암호를 찾아낸다. 특히, brute force algorithm (이하, BF)를 이용하여 암호를 생성할 때는 암호가 어떠한 길이로 되어있는지, 혹은 어떤 문자로 구성되어 있는지 대입하는 공격자는 아는 정보가 없다는 가정이 존재한다.

### 문제 분석
BF는 단순히 모든 가짓수의 여러 유형의 암호를 생성해 무차별적으로 대입하는 방식이라 알고리즘을 구현하는 데에 있어 어려움은 없지만, 많은 연산량으로 인해 CPU의 단일 코어만 사용한다면 시간이 오래 걸릴 것으로 예상이 되었다.
따라서, 이를 효율적으로 해결하기 위해 병렬 프로그램을 이용하기로 계획하였으며, CUDA 병렬 프로그래밍을 통해 단일 CPU로 처리하는 방식보다 빠르게 암호를 찾으려고 하였다. 또한, 아직 CUDA 프로그래밍에 미숙하여 관련 CUDA 프로그래밍과 BF와 관련하여 github에 올라온 공개 소프트웨어를 사용해보고, 직접 해당 프로그램의 알고리즘을 개선하여 시간을 비교해볼 수 있도록 하였다.

### 코드 설명
프로그램은 크게 세 개의 파일로 나누어져 있으며, 각각 “BF_cuda_cracking.cu”, “BF_passwords.hpp”, “BF_passwords.cpp”이다. “BF_cuda_cracking.cu”는 CUDA 병렬 프로그래밍으로 BF 알고리즘을 주요하게 수행하는 프로그램이고, “BF_passwords.hpp”는 암호에 들어갈 문자를 정의하고 해당 문자를 이용하여 7가지 유형의 암호를 생성하는 프로그램이다. “BF_passwords.cpp”는 앞선 헤더 파일에서 정의한 클래스 메소드를 정의하고 기타 사용자 함수를 정의한 프로그램이다.
또한,  코드는 우분투 리눅스 빌드 및 실행할 수 있도록 작성하였으며, 프로그램을 여러 파일로 나눠 작성하고 nvcc 컴파일러와 Makefile을 이용하여 컴파일을 진행함으로써, 프로그램을 유지 보수를 쉽게 하려고 노력하였으며, 프로그램의 구조를 한눈에 파악할 수 있도록 하였다.

### 결과
6자리까지 확인한 후 log 파일을 확인하였으며, 프로그램한 대로 찾은 암호와 경과 시간을 확인해볼 수 있었다. 4자리와 5자리의 경우 480ms, 6자리의 경우 5,000ms 정도의 경과 시간을 확인할 수 있었다. 특이하게도 여러 번 수행할수록 경과 시간이 점점 길어지는 것을 확인할 수 있었는데, 이는 하드웨어의 발열로 인한 스로틀링(throttling)으로 추측해볼 수 있었다.

- 참고한 코드: https://github.com/hyunsooda/Parallel-Brute-Force-Algorithm
